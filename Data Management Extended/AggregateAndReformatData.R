# Агрегирование и переформатирование данных
####                                Транспонирование                              ####
# Транспонирование (переворот таблицы на 90°, когда строки и столбцы меняются местами) –
# наверное, самый простой способ переформатирования данных. Используйте функцию t(), чтобы
# транспонировать матрицу или таблицу данных. В последнем случае названия строк становятся
# именами переменных (столбцов). Пример представлен в приведенном ниже программном коде.
cars <- mtcars[1:5,1:4]
cars
t(cars)
# Позже в этом разделе вы познакомитесь с более гибким способом транспонирования данных,
# когда мы рассмотрим пакет shape.


####                            Агрегирование данных                              ####
# В R довольно просто компактизировать данные, используя заданную функцию и одну или более
# переменных в качестве критерия (by). Формат применения функции таков:
#  aggregate(x, by, FUN)
# где x – это исходный объект с данными, by – это перечень переменных, которые будут служить
# критерием для компактизации, а FUN – это скалярная функция, которая используется для расчета
# стастистик, которые послужат значениями нового объекта с данными.
# В качестве примера мы агрегируем данные mtcars по числу цилиндров и передач, вычислив
# средние арифметические всех числовых переменных (см. следующий программный код).
options(digits=3)
attach(mtcars)
aggdata <-aggregate(mtcars, by=list(cyl,gear), FUN=mean, na.rm=TRUE)
aggdata
detach(mtcars)
# В представленных результатах Group.1 – это число цилиндров (4, 6 или 8), а Group.2 – это число
# передач (3, 4 или 5). Например, машинам с четырьмя цилиндрами и тремя передачами в среднем
# хватает одного галлона топлива, чтобы проехать в среднем 21.5 миль (mpg – miles per gallon).
# При использовании функции aggregate() переменные, по которым идет агрегация (by),
# должны быть представлены в виде списка (даже если туда входит всего одна переменная). Каждой
# группе из списка можно дать удобное название, например, так: by=list(Group.cyl=cyl,
# Group.gears=gear). Для агрегирования данных можно использовать любую встроенную или
# пользовательскую функцию. Это дает команде aggregate() большие возможности. Однако когда
# дело касается больших возможностей, ничто не затмит пакет reshape.



####                                Пакет reshape                                     ####
# Пакет reshape – это потрясающе многогранный подход и к реструктуризации, и к преобразованию
# данных. Из-за этой многогранности он может оказаться несколько трудным для освоения. Мы будем
# двигаться медленно, используя маленький объем данных, так, чтобы всегда было ясно, что
# происходит. Поскольку пакет reshape не включен в базовую версию R, его нужно сначала
# установить, набрав install.packages("reshape").
# Основная идея состоит в том, что вы «расплавляете» ваши данные, так что каждая строка
# представляет собой уникальную комбинацию идентификационных переменных и собственно
# переменных, несущих информацию. Затем вы «слепляете» расплавленные данные в любую нужную
# вам форму. Во время «лепки» можно агрегировать данные при помощи любой функции.

library(reshape)

# Creating a new dataset
ID <- c(1,1,2,2)
Time <- c(1,2,1,2)
X1 <- c(5,3,6,2)
X2 <- c(6,5,1,4)
mydata <- data.frame(ID, Time, X1, X2)

# В этом наборе данных измерения (X1, X2) – это значения в последних двух столбцах (5, 6, 3, 5, 6, 1, 2
# и 4). Каждое измерение обозначено уникальной комбинацией идентификационных переменных (в
# этом случае ID и Time). Например, значение измерения 5 в первом ряду можно обозначить
# уникальной комбинацией значения ID равного 1 и значения Time равного 1, зная, что оно
# принадлежит переменной X1.


# «Расплавление»
# Когда вы «расплавляете» данные, вы преобразуете их в такой формат, что каждая измеренная
# переменная расположена в собственной строке вместе с переменными, необходимыми для того,
# чтобы уникально обозначить ее:
md <- melt(mydata, id=(c("ID", "Time")))
# Обратите внимание на то, что вы должны указать переменные, которые необходимы для
# уникального обозначения каждого измерения (ID и Time) и на то, что переменная, в которой
# записаны названия столбцов с измерениями (X1 и X2), создается автоматически.
# Теперь, когда ваши данные «расплавлены», им можно придать любую форму, используя
# функцию cast().

# Придание данным формы
# Функция cast() применяется к «расплавленным» данным и придает им заданную форму,
# используя введенную формулу и еще функцию (это не обязательно) для агрегирования данных.
# Формат таков:
#   newdata <- cast(md, formula, FUN)
# где md – это «расплавленные» данные, formula описывает желаемый результат, FUN –
# необязательная функция для агрегирования. Формула имеет вид
# rowvar1 + rowvar2 + ... ~ colvar1 + colvar2 + ...
# В такой формуле rowvar1 + rowvar2 + ... задает набор переменных, которые определяют
# строки, а colvar1 + colvar2 + ... – набор переменных, определяющих столбцы.
# С группировкой:
cast(md, ID~variable, mean)
cast(md, ID~Time, mean)
# Без группировки:
cast(md, ID+Time~variable)
cast(md, ID+variable~Time)
cast(md, ID~variable+Time)