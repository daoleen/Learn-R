# Задача по управлению данными, которую нужно решить
# Прежде чем начинать обсуждение числовых и текстовых функций, давайте рассмотрим одну задачу
# по управлению данными. Группа студентов сдавала экзамены по математике, естественным наукам и
# английскому языку. Вы хотите объединить их баллы по трем предметам, чтобы получить единый
# показатель успеваемости для каждого студента. Кроме того, вы хотите поставить оценку A первым
# по успеваемости 20% студентов, оценку B – следующим по успеваемости 20% и так далее. Наконец,
# вы хотите отсортировать студентов в алфавитном порядке.
# При взгляде на эти данные немедленно обнаруживается ряд проблем. Во-первых, баллы, полученные
# за разные экзамены несопоставимы между собой. Их средние значения и стандартные отклонения
# сильно различаются, так что усреднять их не имеет смысла. Для вычисления единого показателя
# успеваемости необходимо преобразовать эти баллы так, чтобы их можно было сопоставлять между
# собой. Во-вторых, нам понадобится метод для определения места студентов в общем рейтинге
# успеваемости, чтобы поставить им итоговую оценку. В-третьих, для нормальной сортировки
# студентов в алфавитном порядке нужно будет разбить первый столбец на два – с именем и
# фамилией.

# В задаче требуется объединить результаты экзаменов по каждому предмету в
# единый балл успеваемости для каждого студента, поставить каждому студенту оценку от A до F в
# зависимости от позиции в общем рейтинге (верхние 20%, следующие 20% и т.д.) и отсортировать
# строки в списке по фамилии студентов, а затем и по имени. Решение этой задачи представлено в
# приведенном ниже программном коде.

# Шаг 1. Дан исходный список студентов. Команда options(digits=2) сокращает до двух число
# знаков после запятой у всех выводимых на экран чисел, это упрощает их восприятие.
options(digits=2)
Student <- c("John Davis", "Angela Williams", "Bullwinkle Moose",
               "David Jones", "Janice Markhammer", "Cheryl Cushing",
               "Reuven Ytzrhak", "Greg Knox", "Joel England",
               "Mary Rayburn")
Math <- c(502, 600, 412, 358, 495, 512, 410, 625, 573, 522)
Science <- c(95, 99, 80, 82, 75, 85, 80, 95, 89, 86)
English <- c(25, 22, 18, 15, 20, 28, 15, 30, 27, 18)
roster <- data.frame(Student, Math, Science, English, stringsAsFactors=FALSE)

# Шаг 2. Поскольку оценки по математике, естественным наукам и английскому языку выставлены по
# разным шкалам (их среднее и стандартное отклонение заметно различаются), вам необходимо
# сделать их сопоставимыми, прежде чем комбинировать. Один из способов выполнить эту задачу –
# стандартизировать переменные так, чтобы результат каждого теста был выражен в стандартных
# отклонениях, а не в исходных баллах. Это можно сделать при помощи функции scale():
z <- scale(roster[,2:4]) # Вычисляем объединенный показатель успеваемости

# Шаг 3. Можно рассчитать показатель успеваемости студентов, усреднив значения
# стандартизированных баллов для каждой строки посредством функции mean() и добавив их к
# списку при помощи функции cbind():
score <- apply(z, 1, mean)
roster <- cbind(roster, score)

# Шаг 4. Функция quantile() позволяет вычислить границы значений 20%-ных интервалов
# (перцентилей) показателя успеваемости. Вы видите, что нижняя граница для оценки A равна 0.74,
# для оценки B – 0.44 и т.д.
y <- quantile(score, c(.8,.6,.4,.2)) # Оцениваем студентов

# Шаг 5. Используя логические операторы, вы можете перекодировать значения показателя
# успеваемости в новую категориальную переменную итоговой оценки. Для этого вы создаете
# переменную grade в таблице данных roster.
roster$grade[score >= y[1]] <- "A"
roster$grade[score < y[1] & score >= y[2]] <- "B"
roster$grade[score < y[2] & score >= y[3]] <- "C"
roster$grade[score < y[3] & score >= y[4]] <- "D"
roster$grade[score < y[4]] <- "F"

# Шаг 6. Нам понадобится использовать функцию strsplit(), чтобы разделить пробелом имена и
# фамилии студентов.
name <- strsplit((roster$Student), " ") # Извлекаем фамилии и имена

# Шаг 7. Можно использовать функцию sapply() чтобы поместить первый элемент каждого
# компонента списка в вектор с именами, а второй – в вектор с фамилиями. “[” – это функция,
# которая выбирает часть объекта – в данном случае, первый или второй элемент листа name. Вам
# потребуется применить функцию cbind(), чтобы добавить вектора с именами и фамилиями к
# списку. Поскольку вам больше не нужна переменная с именем и фамилией каждого студента, можно
# от нее избавиться (при помощи -1 в индексе при названии списка).
lastname <- sapply(name, "[", 2)
firstname <- sapply(name, "[", 1)
roster <- cbind(firstname,lastname, roster[,-1])

# Шаг 8. Наконец, можно отсортировать список по именам и фамилиям студентов при помощи
# функции order():
roster <- roster[order(lastname,firstname),] # Сортируем по фамилиям и именам
roster


