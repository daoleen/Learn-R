####                                Объединение данных                                ####
# Если ваши данные существуют в виде разрозненных фрагментов, их нужно объединить, прежде чем
# двигаться дальше. В этом разделе рассказано, как добавлять столбцы (переменные) и строки
# (наблюдения) к таблице данных.

## Добавление столбцов
# Для того чтобы объединить две таблицы данных в горизонтальном направлении, нужно использовать
# функцию merge(). В большинстве случаев, две таблицы объединяются по значениям одной или
# нескольких ключевых переменных. К примеру, команда
total <- merge(dataframeA, dataframeB, by="ID")
# объединяет таблицы данных dataframeA и dataframeB по значениям переменной ID.
# Аналогично, команда
total <- merge(dataframeA, dataframeB, by=c("ID","Country"))
# объединяет две таблицы данных по значениям переменных ID и Country. Подобное объединение
# таблиц данных в горизонтальном направлении часто используется для добавления переменных к
# таблице
# Примечание. Если вы хотите объединить две матрицы или таблицы данных в горизонтальном
# направлении, и вам не нужно указывать значения переменной, по которым произойдет объединение,
# можете использовать функцию cbind():
total <- cbind(A, B)
# Эта команда объединяет объекты A и B в горизонтальном направлении. Для того чтобы функция 
# работала правильно, каждый объект должен иметь одинаковое число строк, расположенных в 
# одинаковом порядке.


## Добавление строк
# Для того чтобы объединить две таблицы данных в вертикальном направлении, используйте функцию
# rbind():
total <- rbind(dataframeA, dataframeB)
# Объединяемые таблицы должны состоять из одинаковых переменных, но эти переменные не
# обязательно должны быть расположены в одной и той же последовательности. Если в таблице
# dataframeA есть переменные, которых нет в таблице dataframeB, тогда перед объединением
# этих таблиц нужно сделать одно из двух:
# - удалить лишние переменные из таблицы dataframeA;
# - создать дополнительные переменные в таблице dataframeB и присвоить им значения NA
# (пропущенные).
# Слияние таблиц в вертикальном направлении обычно используется для добавления наблюдений в
# таблицу данных.



####                 Разделение наборов данных на составляющие                       ####
# В R есть обширные возможности для обозначения частей объектов. Эти возможности можно
# использовать для выбора и исключения переменных и/или наблюдений. В приведенных ниже
# разделах обсуждаются несколько способов выбора или удаления переменных и наблюдений.

## Выбор переменных
# Часто бывает так, что новый набор данных создается из небольшого числа переменных, выбранных
# из большего набора данных. В главе 2 вы узнали, как выбирать элементы таблицы данных при
# помощи команды типа таблица_данных[номера_строк, номера_столбцов]. Этот прием
# можно использовать для выбора отдельных переменных. К примеру, команда
newdata <- leadership[,c(6:10)]
# позволяет выбрать переменные q1, q2, q3, q4 и q5 из таблицы данных leadership и сохранить
# их в таблице данных newdata. Не указывая номера строк (,), мы по умолчанию выбираем все
# строки.
# При помощи команд
myvars <- c("q1", "q2", "q3", "q4", "q5")
newdata <-leadership[myvars]
# можно выбрать те же самые переменные. В этом случае имена переменных (в кавычках)
# используются для обозначения переменных, которые должны быть выбраны.
# Наконец, для выполнения той же задачи вы могли бы использовать команды
myvars <- paste("q", 1:5, sep="")
newdata <- leadership[myvars]
# В этом примере для создания такого же вектора, как в предыдущем случае, использована функция
# paste(). Эту функцию мы подробно рассмотрим в главе 5.


####                               Исключение переменных                         ####
# Существует много причин для того, чтобы исключить переменные. Например, в том случае, если
# переменная содержит несколько пропущенных значений, вам может понадобиться удалить ее перед
# тем, как анализировать данные. Давайте рассмотрим несколько способов удаления переменных.
# Переменные q3 и q4 можно удалить при помощи следующих команд
myvars <- names(leadership) %in% c("q3", "q4")
newdata <- leadership[!myvars]
# Для того чтобы понять, как это работает, рассмотрим команды по частям:
#  1. names(leadership) создает текстовый вектор, содержащий названия переменных:
#  c("managerID","testDate","country","gender","age","q1",
#    "q2","q3","q4","q5").

# 2. myvars <- names(leadership) %in% c("q3", "q4") возвращает логический
# вектор со значениями TRUE для каждого элемента вектора names(leadership), который
# соответствует q3 или q4, и со значениями FALSE в противном случае: 
# c(FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, TRUE, TRUE, FALSE).

# 3. Оператор «не» (!) меняет логические значения на противоположные: 
# c(TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, TRUE).

# 4. leadership[c(TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, TRUE)] 
# выбирает столбцы, для которых значения логического вектора равны
# TRUE, так что q3 и q4 исключаются.

# Зная, что q3 и q4 – это восьмая и девятая переменные, вы можете удалить их 
# при помощи команды
newdata <- leadership[c(-8,-9)]
# Это работает, поскольку минус перед номером столбца означает, что этот столбец должен быть
# удален.

# Наконец, эти же два столбца можно удалить при помощи команды
leadership$q3 <- leadership$q4 <- NULL
# Теперь вы назначаете эти столбцы неопределенными (NULL). Обратите внимание, что 
# NULL – это не то же самое, что NA (отсутствующие значения).
# Удаление переменных – действие, противоположное отбору переменных. Выбор между этими
# действиями зависит от того, какое из них легче осуществить. Если нужно удалить много
# переменных, может быть, проще выбрать остающиеся, и наоборот.


####                            Выбор наблюдений                                    ####
# Выбор или удаление наблюдений (строк) – это, в большинстве случаев, залог успешной подготовки
# данных и их анализа. Несколько примеров содержатся в приведенном ниже программном коде.
newdata <- leadership[1:3,]

newdata <- leadership[which(leadership$gender=="M" & leadership$age > 30),]

attach(leadership)
newdata <- leadership[which(gender=='M' & age > 30),]
detach(leadership)

# В каждом из этих примеров приведены номера строк, а место для номеров столбцов оставлено
# пустым (то есть выбраны все столбцы). В первом примере вы выбираете строки с первой по третью
# (первые три наблюдения).
# Во втором примере вы выбираете всех мужчин старше 30 лет. Давайте рассмотрим эту строку
# программного кода по частям, чтобы понять его.
# 1. Логическое выражение leadership$gender=="M" создает вектор 
# c(TRUE, FALSE, FALSE, TRUE, FALSE).

# 2. Логическое выражение leadership$age > 30 создает вектор 
# c(TRUE, TRUE, FALSE, TRUE, TRUE).

# 3. Логическое выражение 
# c(TRUE, FALSE, FALSE, TRUE, FALSE) & c(TRUE, TRUE, FALSE, TRUE, TRUE) 
# создает вектор 
# c(TRUE, FALSE, FALSE, TRUE, FALSE).

# 4. Функция which() возвращает номера элементов вектора, которые представлены значением
# TRUE. Таким образом, выражение 
# which(c(TRUE, FALSE, FALSE, TRUE, FALSE))
# возвращает вектор 
# c(1, 4).

# 5. Команда leadership[c(1,4),] выбирает из таблицы данных первое и четвертое
# наблюдения, которые удовлетворяют нашим критериям (мужчины старше 30 лет).

# В третьем примере использована функция attach(),чтобы вам не нужно было писать перед
# каждым именем переменной название таблицы данных.
# В начале этой главы я предположил, что при анализе данных вы можете захотеть
# ограничиться наблюдениями, сделанными в период между 1 января и 31 декабря 2009 года. Как это
# можно осуществить? Вот одно из возможных решений:
leadership$date <- as.Date(leadership$date, "%m/%d/%y")
startdate <- as.Date("2009-01-01")
enddate <- as.Date("2009-10-31")
newdata <- leadership[which(leadership$date >= startdate & leadership$date <= enddate),]
# Преобразуйте даты, которые исходно воспринимались программой как текстовые значения, в формат
# даты (мм/дд/гг). Затем назначьте начальную и конечную даты временного отрезка. Поскольку по
# умолчанию функция as.Date() уже создает даты в формате гггг/мм/дд, вам не нужно указывать
# формат. Наконец, выберите наблюдения, которые удовлетворяют заданному критерию, как вы
# делали в предыдущем примере.



####                                Функция subset()                                  ####
# Примеры, приведенные в предыдущих двух разделах, важны, поскольку они помогают понять, как R
# интерпретирует логические векторы и операторы сравнения. Понимание принципа работы этих
# примеров поможет понять общие принципы действия программного кода в R. Теперь, после того,
# как вы освоили сложные способы, посмотрим, как сделать это проще.
# Функция subset() – возможно, самый простой способ выбора переменных и наблюдений.
# Вот два примера:
newdata <- subset(leadership, age >= 35 | age < 24,
                  select=c(q1, q2, q3, q4))

newdata <- subset(leadership, gender=="M" & age > 25,
                  select=gender:q4)
# В первом примере вы выбираете все строки, в которых значение переменной age больше или равно
# 35 или меньше 24, оставляя переменные с q1 по q4. Во втором примере вы отбираете всех мужчин
# старше 25 лет, оставляя переменные с gender по g4 (gender, g4 и все столбцы, находящиеся
# между ними). Вы уже видели оператор двоеточие в выражениях типа от:до в главе 2. Здесь этот
# оператор позволяет оставить все переменные в таблице данных, начиная с переменной от и
# заканчивая переменной до.