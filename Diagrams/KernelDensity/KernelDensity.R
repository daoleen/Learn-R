# Диаграммы плотности ядра
# В разделе о гистограммах видели диаграмму плотности ядра, добавленную к гистограмме. С
# технической точки зрения оценка плотности ядра – это непараметрический метод оценки значений
# функции вероятности плотности случайной переменной. Хотя математические выкладки выходят за
# рамки этого текста, в целом диаграммы плотности ядра – хороший способ изобразить распределение
# значений непрерывной переменной. Способ построения диаграммы плотности (которая не будет
# наложена на другую диаграмму) таков:
#  plot(density(x))
# где x – это числовой вектор. Поскольку команда plot() начинает строить новую диаграмму,
# используйте команду lines() (программный код 6.6), когда вы хотите добавить кривую плотности
# к уже существующей диаграмме.

par(mfrow=c(2,1))

d <- density(mtcars$mpg)
plot(d)

d <- density(mtcars$mpg)
plot(d, main="Kernel Density of Miles Per Gallon")
polygon(d, col="red", border="blue")
rug(mtcars$mpg, col="brown")

# На первой диаграмме вы видите минималистский вариант, то, что получается по умолчанию. На
# второй диаграмме вы добавляете название, красите кривую в синий цвет, пространство под ней
# заполняете красным и добавляете график-щетку с коричневыми делениями. Команда polygon()
# позволяет изобразить многоугольник, вершины которого задаются x и y координатами (в данном
# случае они определяются функцией density()).
# Диаграммы плотности ядра можно использовать для сравнения групп. Этот подход
# применяется гораздо реже, чем он заслуживает, возможно, из-за отсутствия легко доступных
# программ. К счастью, пакет sm замечательно восполняет этот недостаток.


# Функция sm.density.compare() пакета sm позволяет наложить друг на друга диаграммы
# плотности ядра для двух и более групп. Формат применения функции таков:
#  sm.density.compare(x, factor)
# где x – это числовой вектор и factor – переменная, определяющая принадлежность к группе. Не
# забудьте установить пакет sm перед его первым использованием. Пример, в котором сравнивается
# расход топлива для машин с 4, 6 и 8 цилиндрами, приведен в программном коде ниже:

#Удваиваем ширину линий
par(lwd=2) 
library(sm)
attach(mtcars)

# Создаем фактор с номером группы
cyl.f <- factor(cyl, levels= c(4,6,8),
                labels = c("4 cylinder", "6 cylinder", "8 cylinder")
)

# Отображаем плотности распределения точек
sm.density.compare(mpg, cyl, xlab="Miles Per Gallon") 
title(main="MPG Distribution by Car Cylinders") 
colfill<-c(2:(1+length(levels(cyl.f))))

# Добавляем легенду по щелчку мыши
legend(locator(1), levels(cyl.f), fill=colfill)
detach(mtcars)

# Функция par() используется, чтобы удвоить толщину линий на диаграмме (lwd=2), так их легче
# воспринимать читателям . Пакет sm загружен и таблица данных mtcars активирована.
# В таблице данных mtscars  cyl – это числовая переменная, принимающая значения 4, 6, 8.
# Она преобразована в фактор, названный cyl.f, в котором содержатся подписи к диаграмме.
# Функция sm.density.compare создает диаграмму , а функция title() добавляет ее
# название.
# Наконец, вы добавляете легенду, чтобы сделать диаграмму понятнее  (легенды обсуждались
# в главе 3). Сначала мы создаем вектор цветов. Здесь colfill равно c (2, 3, 4). Затем
# добавляем легенду на диаграмму при помощи функции legend(). Опция locator(1) означает
# то, что вы разместите легенду на диаграмме в интерактивном режиме, указав курсором на то место,
# где она должна появиться. Вторая опция представляет собой текстовый вектор, содержащий
# подписи. Третья опция присваивает цвет из вектора colfill каждому уровню фактора cyl.f.

# Видно, что при помощи наложенных друг на друга диаграмм плотности ядра можно эффективно
# сравнить группы данных. Здесь видны и форма распределения значений в каждой группе, и степень
# перекрытия между группами. Мораль этой истории заключается в том, что у моей следующей
# машины будет восемь цилиндров – или аккумулятор.