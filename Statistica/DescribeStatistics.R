# Когда дело доходит до вычисления описательных статистик, R потрясает воображение. Давайте
# начнем с функций, которые включены в базовую версию. Затем мы познакомимся с расширенными
# возможностями, которые становятся доступными при установке дополнительных пакетов.
# В базовой версии реализована функция summary(), которая позволяет вычислить
# описательные статистики. Пример содержится в следующем программном коде.
source('data.R')

summary(mtcars[vars])
# Функция summary() позволяет вычислить минимум, максимум, квартили и среднее для числовых
# переменных или частоты значений для факторов и логических векторов. Можно такжн использовать
# функции apply() или sapply(), описанные в главе 5, чтобы вычислить любую описательную
# статистику. Формат применения функции sapply() таков:
#  sapply(x, FUN, options)
# где x – это таблица данных (или матрица), а FUN – произвольная функция. Если опции (options)
# указаны, они относятся к функции FUN. Обычно в этом случае используются такие функции как
# mean, sd, var, min, max, median, length, range и quantile. Функция fivenum() вычисляет
# пять описательных статистик Тьюки (Tukey) (минимум, нижняя квартиль, медиана, верхняя
# квартиль, максимум).

# Удивительно, но в базовой версии программы нет функций для характеристики ассиметрии и
# эксцесса распределения значений, но вы можете создать такие функции самостоятельно. Пример в
# следующем программном коде демонстрирует, как вычислить несколько описательных статистик,
# включая ассиметрию и эксцесс.
mystats <- function(x, na.omit=FALSE) {
  if (na.omit) {
    x <- x[!is.na(x)]
  }
  
  m <- mean(x)
  n <- length(x)
  s <- sd(x)
  skew <- sum((x-m)^3/s^3)/n
  kurt <- sum((x-m)^4/s^4)/n - 3
  
  return(c(n=n, mean=m, stdev=s, skew=skew, kurtosis=kurt))
}
sapply(mtcars[vars], mystats)
# Для автомобилей из этого примера средний расход топлива составляет 20.1 миль на галлон со
# стандартным отклонением 6.0. Максимум кривой распределения значений смещен вправо (+0.61) и
# находится немного ниже, чем это бывает в случае нормального распределения (-0.37). Это будет
# лучше всего заметно при графическом изображении данных. Учтите, что если бы вы хотели бы
# удалить строки с пропущенными значениями, то нужно было написать sapply(mtcars[vars],
# mystats, na.omit=TRUE).


# Дополнительные возможности
# Функции для вычисления описательных статистик реализованы в нескольких дополнительных
# пакетах, включая пакеты Hmisc, pastecs и psych. Не забудьте установить эти пакеты перед
# первым использованием, поскольку они не входят в базовую версию программы.
# Функция describe() из пакета Hmisc выводит на экран число переменных и наблюдений,
# число пропущенных и неповторяющихся значений, среднее, квартили, а также пять самых маленьких
# и пять самых больших значений. Пример представлен в следующем программном коде.
# Программный код 7.3. Вычисление описательных статистик при помощи функции describe() из
# пакета Hmisc
library(Hmisc)
describe(mtcars[vars])

# В пакете pastecs есть функция stat.desc(), которая позволяет вычислить множество
# описательных статистик. Формат ее применения таков:
#   stat.desc(x, basic=TRUE, desc=TRUE, norm=FALSE, p=0.95)
# где x – это таблица данных или временной ряд. Если basic=TRUE (по умолчанию), то вычисляется
# число значений, число нулей и пропущенных значений, минимум, максимум, размах и сумма. Если
# desc=TRUE (тоже по умолчанию), то вычисляются медиана, среднее арифметическое, стандартная
# ошибка среднего, 95% доверительный интервал для среднего, дисперсия, стандартное отклонение и
# коэффициент вариации. Наконец, если norm=TRUE (не по умолчанию), вычисляются статистики
# нормального распределения, включая ассиметрию и эксцесс (и их достоверность) и проводится тест
# Шапиро-Уилка (Shapiro-Wilk test) на нормальность распределения. Опция p используется при
# вычислении доверительного интервала для среднего арифметического (по умолчанию она равна
# 0.95). Пример дан в программном коде 7.4.
# Программный код 7.4. Вычисление описательных статистик при помощи функции stat.desc()
# пакета pastecs
library(pastecs)
stat.desc(mtcars[vars])

# Как будто этого недостаточно, в пакете psych тоже есть функция под названием describe(),
# которая выводит на экран число непропущенных значений, среднее арифметическое, стандартное
# отклонение, усеченное среднее, минимум, максимум, размах, ассиметрию, эксцесс и стандартную
# ошибку среднего. Пример приведен в следующем программном коде.
# Программный код 7.5. Вычисление описательных статистик при помощи функции describe()
# пакета psych
library(psych)
describe(mtcars[vars])

# Я же говорил вам, что это потрясает воображение!
# Замечание. В рассмотренных примерах функция с названием describe() была и в пакете psych,
# и в пакете Hmisc. Откуда R знает, какую выбрать? Очень просто, преимущество имеет пакет,
# загруженный последним, как это видно из программного кода 7.5. В данном случае пакет psych
# загружен после Hmisc, и на экран выводится сообщение о том, что функция describe() из
# пакета Hmisc «замаскирована» функцией с таким же названием из пакета psych. Когда вы
# пишете название этой функции, R начинает поиск с пакета psych и выполняет ее. Если вы хотите
# вместо этого воспользоваться функцией из пакета Hmisc, можете набрать
# Hmisc::describe(mt). Эта функция никуда не делась. Просто нужно дать программе больше
# информации для ее поиска.
# Теперь, когда вы узнали, как вычислять описательные статистики для данных в целом, давайте
# рассмотрим, как получить их для групп данных.



####                  Вычисление описательных статистик для групп данных              ####
# При сравнении групп объектов или наблюдений обычно обращают внимание на значения
# описательных статистик для каждой группы, а не для всей выборки в целом. Опять же, в R
# реализовано несколько способов достижения цели. Мы начнем с вычисления описательных
# статистик для каждого типа коробки передач.
# В главе 5 мы обсудили способы объединения данных в группы. При вычислении
# описательных статистик для отдельных групп данных можно использовать функцию aggregate(),
# как это показано в следующем программном коде.
# Программный код 7.6. Вычисление описательных статистик для отдельных групп с использованием
# функции aggregate()
aggregate(mtcars[vars], by=list(am=mtcars$am), mean)
aggregate(mtcars[vars], by=list(am=mtcars$am), sd)

# Обратите внимание на использование выражения list(am=mtcars$am). Если бы вы написали
# list(mtcars$am), то столбец am был бы назван не am, а Group.1. Здесь мы использовали знак
# присвоения, чтобы подписать столбец более содержательно. Если у вас есть больше одной
# группирующей переменной, можно использовать код вроде этого: by=list(name1=groupvar1,
# name2=groupvar2, ... , groupvarN).
# К сожалению, функцию aggregate() можно использовать только для вычисления одной
# статистики, такой как среднее, стандартное отклонение и подобных им, за один раз. Для
# одновременного вычисления нескольких статистик используйте функцию by(). Формат ее
# применения таков:
#  by(data, INDICES, FUN)
# где data – это таблица данных или матрица, INDICES – фактор или список факторов, который
# определяет группы и FUN – произвольная функция. Приведенный ниже программный код содержит
# пример.
# Программный код 7.7. Вычисление описательных статистик для групп данных при помощи функции
# by()
dstats <- function(x)(c(mean=mean(x), sd=sd(x)))
by(mtcars[vars], mtcars$am, dstats)

# Дополнительные возможности
# В пакетах doBy и psych реализованы команды, вычисляющие описательные статистики для групп
# данных. Опять же, эти пакеты не поставляются с базовой версией и должны быть установлены перед
# первым использованием. Функция summaryBy из пакета doBy имеет такой формат применения:
#  summaryBy(formula, data=dataframe, FUN=function)
# где formula принимает вид
# var1 + var2 + var3 + ... + varN ~ groupvar1 + groupvar2 + ... + groupvarN
# Переменные слева от знака ~ – это числовые переменные, которые нужно проанализировать, а
# переменные справа – это категориальные группирующие переменные. В качестве function можно
# использовать любую имеющуюся или заново созданную функцию. Пример с функцией mystats,
# которую мы создали в разделе 7.2.1, дан в приведенном ниже программном коде.
# Программный код 7.8. Вычисление описательных статистик для групп при помощи функции
# summaryBy() из пакета doBy
library(doBy)
summaryBy(mpg+hp+wt~am, data=mtcars, FUN=mystats)

# Как вы увидите из приведенного ниже программного кода, функция describe.by() из пакета
# phych() позволяет вычислить те же описательные статистики, что и функция describe(), только
# отдельно для каждой группы.
# Программный код 7.9. Вычисление описательных статистик для групп при помощи функции
# describe.by() из пакета psych
library(psych)
describe.by(mtcars[vars], mtcars$am)
# В отличие от предыдущего примера, при использовании команды describe.by() нельзя указать
# произвольную функцию, так что эта команда менее широко применима. Если у вас есть более одной
# группирующей переменной, то их можно записать в виде list(groupvar1, groupvar2, ... ,
# groupvarN). Однако это будет работать только в том случае, если всем сочетаниям группирующих
# переменных соответствуют какие-то значения исследуемой переменной.
# Наконец, можно использовать описанный в разделе 5.6.3 пакет reshape, чтобы вычислить
# описательные статистики для групп. Если вы не читали этот раздел, я советую вам сделать это,
# прежде чем продолжать. Сначала мы «растворяем» данные, используя выражение
# dfm <- melt(dataframe, measure.vars=y, id.vars=g)
# где dataframe содержит данные, y – вектор, который определяет, какие данные анализировать (по
# умолчанию все), а g – вектор, содержащий одну или более группирующих переменных. Затем вы
# «собираете» данные при помощи выражения
# cast(dfm, groupvar1 + groupvar2 + ... + variable ~ ., FUN)
# где группирующие переменные разделены знаками +, слово variable так и должно быть написано,
# а FUN – произвольная функция.

# В последнем примере этого раздела мы применим подход, реализованный в пакете reshape,
# чтобы вычислить описательные статистики для каждой подгруппы, определенной сочетанием типа
# коробки передач и числа цилиндров. В качестве описательных статистик мы выбрали размер
# выборки, среднее и стандартное отклонение. Функции и результат представлены в приведенном
# ниже программном коде.
# Программный код 7.10. Вычисление описательных статистик для групп с использованием пакета
# reshape
library(reshape)
dstats <- function(x)(c(n=length(x), mean=mean(x), sd=sd(x)))
dfm <- melt(mtcars, measure.vars=c("mpg", "hp", "wt"), id.vars=c("am", "cyl"))
cast(dfm, am + cyl + variable ~ ., dstats)

# Лично мне этот подход кажется наиболее лаконичным и привлекательным. Люди, которые
# анализируют данные, имеют свои предпочтения относительно того, какие описательные статистики
# вычислять и в каком виде выводить результаты на экран. Наверное, поэтому существует столько
# способов вычисления описательных статистик. Выберите тот, который больше вам подходит, или
# разработайте свой собственный!



####                            Визуализация результатов                                ####
# Представление характеристик распределения данных в числовом виде полезно, но оно не заменяет
# собой его графическое изображение. Для количественных данных подходят гистограммы (раздел
# 6.3), диаграммы плотности рассеяния (раздел 6.4), ящики с усами (раздел 6.5) и точечные диаграммы
# (раздел 6.6). Они способны дать понимание вещей, которые могут быть легко упущены, если
# полагаться на небольшой набор описательных статистик.
# Функции, которые мы рассматривали до сих пор, позволяют охарактеризовать
# количественные данные. Функции, описанные в следующем разделе, предназначены для анализа
# распределения категориальных переменных.